diff --git a/include/pluginlib/class_loader_imp.hpp b/include/pluginlib/class_loader_imp.hpp
index a41790b..489e4c7 100644
--- a/include/pluginlib/class_loader_imp.hpp
+++ b/include/pluginlib/class_loader_imp.hpp
@@ -65,11 +65,16 @@
 #define CLASS_LOADER_IMPL_OS_PATHSEP ":"
 #endif
 
+namespace
+{
+#define NOINLINE __attribute__ ((noinline))
+}
+
 namespace pluginlib
 {
 
 template<class T>
-ClassLoader<T>::ClassLoader(
+NOINLINE ClassLoader<T>::ClassLoader(
   std::string package,
   std::string base_class,
   std::string attrib_name,
@@ -85,8 +90,11 @@ ClassLoader<T>::ClassLoader(
   lowlevel_class_loader_(false)
   /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Creating ClassLoader, base = %s, address = %p",
-    base_class.c_str(), static_cast<void *>(this));
+  const char * base_class_c_str = base_class.c_str();
+  const void * this_ptr = static_cast<void * >(this);
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader", "Creating ClassLoader, base = %s, address = %p",
+    base_class_c_str, this_ptr);
   try {
     ament_index_cpp::get_package_prefix(package_);
   } catch (const ament_index_cpp::PackageNotFoundError & exception) {
@@ -98,65 +106,78 @@ ClassLoader<T>::ClassLoader(
     plugin_xml_paths_ = getPluginXmlPaths(package_, attrib_name_);
   }
   classes_available_ = determineAvailableClasses(plugin_xml_paths_);
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "Finished constructring ClassLoader, base = %s, address = %p",
-    base_class.c_str(), static_cast<void *>(this));
+    base_class_c_str, this_ptr);
 }
 
 template<class T>
-ClassLoader<T>::~ClassLoader()
+NOINLINE ClassLoader<T>::~ClassLoader()
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  const char * base_class_type_c_str = getBaseClassType().c_str();
+  const void * this_ptr = static_cast<void * >(this);
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "Destroying ClassLoader, base = %s, address = %p",
-    getBaseClassType().c_str(), static_cast<void *>(this));
+    base_class_type_c_str, this_ptr);
 }
 
 
 template<class T>
-T * ClassLoader<T>::createClassInstance(const std::string & lookup_name, bool auto_load)
+T * NOINLINE ClassLoader<T>::createClassInstance(const std::string & lookup_name, bool auto_load)
 /***************************************************************************/
 {
   // Note: This method is deprecated
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  const char * lookup_name_c_str = lookup_name.c_str();
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "In deprecated call createClassInstance(), lookup_name = %s, auto_load = %i.",
-    (lookup_name.c_str()), auto_load);
+    (lookup_name_c_str), auto_load);
 
   if (auto_load && !isClassLoaded(lookup_name)) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Autoloading class library before attempting to create instance.");
     loadLibraryForClass(lookup_name);
   }
 
   try {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Attempting to create instance through low-level MultiLibraryClassLoader...");
     T * obj = lowlevel_class_loader_.createUnmanagedInstance<T>(getClassType(lookup_name));
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Instance created with object pointer = %p", static_cast<void *>(obj));
+    const void * obj_ptr = static_cast<void *>(obj);
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
+      "Instance created with object pointer = %p", obj_ptr);
 
     return obj;
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "CreateClassException about to be raised for class %s",
-      lookup_name.c_str());
+      lookup_name_c_str);
     throw pluginlib::CreateClassException(ex.what());
   }
 }
 
 template<class T>
-std::shared_ptr<T> ClassLoader<T>::createSharedInstance(const std::string & lookup_name)
+std::shared_ptr<T> NOINLINE ClassLoader<T>::createSharedInstance(const std::string & lookup_name)
 /***************************************************************************/
 {
   return createUniqueInstance(lookup_name);
 }
 
 template<class T>
-UniquePtr<T> ClassLoader<T>::createUniqueInstance(const std::string & lookup_name)
+UniquePtr<T> NOINLINE ClassLoader<T>::createUniqueInstance(const std::string & lookup_name)
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  const char * lookup_name_c_str = lookup_name.c_str();
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "Attempting to create managed (unique) instance for class %s.",
-    lookup_name.c_str());
+    lookup_name_c_str);
 
   if (!isClassLoaded(lookup_name)) {
     loadLibraryForClass(lookup_name);
@@ -164,32 +185,38 @@ UniquePtr<T> ClassLoader<T>::createUniqueInstance(const std::string & lookup_nam
 
   try {
     std::string class_type = getClassType(lookup_name);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
-      lookup_name.c_str(), class_type.c_str());
+    const char * class_type_c_str = class_type.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader", "%s maps to real class type %s",
+      lookup_name_c_str, class_type_c_str);
 
     UniquePtr<T> obj = lowlevel_class_loader_.createUniqueInstance<T>(class_type);
 
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "std::unique_ptr to object of real type %s created.",
-      class_type.c_str());
+      class_type_c_str);
 
     return obj;
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Exception raised by low-level multi-library class loader when attempting "
       "to create instance of class %s.",
-      lookup_name.c_str());
+     lookup_name_c_str);
     throw pluginlib::CreateClassException(ex.what());
   }
 }
 
 template<class T>
-T * ClassLoader<T>::createUnmanagedInstance(const std::string & lookup_name)
+T * NOINLINE ClassLoader<T>::createUnmanagedInstance(const std::string & lookup_name)
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Attempting to create UNMANAGED instance for class %s.",
-    lookup_name.c_str());
+  const char * lookup_name_c_str = lookup_name.c_str();
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
+   "Attempting to create UNMANAGED instance for class %s.",
+   lookup_name_c_str);
 
   if (!isClassLoaded(lookup_name)) {
     loadLibraryForClass(lookup_name);
@@ -197,27 +224,32 @@ T * ClassLoader<T>::createUnmanagedInstance(const std::string & lookup_name)
 
   T * instance = 0;
   try {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Attempting to create instance through low level multi-library class loader.");
     std::string class_type = getClassType(lookup_name);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
-      lookup_name.c_str(), class_type.c_str());
+    const char * class_type_c_str = class_type.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader", "%s maps to real class type %s",
+      lookup_name_c_str, class_type_c_str);
     instance = lowlevel_class_loader_.createUnmanagedInstance<T>(class_type);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Instance of type %s created.",
-      class_type.c_str());
+      class_type_c_str);
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Exception raised by low-level multi-library class loader when attempting "
       "to create UNMANAGED instance of class %s.",
-      lookup_name.c_str());
+      lookup_name_c_str);
     throw pluginlib::CreateClassException(ex.what());
   }
   return instance;
 }
 
 template<class T>
-std::vector<std::string> ClassLoader<T>::getPluginXmlPaths(
+std::vector<std::string> NOINLINE ClassLoader<T>::getPluginXmlPaths(
   const std::string & package,
   const std::string & attrib_name)
 /***************************************************************************/
@@ -238,10 +270,13 @@ std::vector<std::string> ClassLoader<T>::getPluginXmlPaths(
       {
         using ament_index_cpp::get_resource;
         if (!get_resource(resource_name, package_prefix_pair.first, resource_content)) {
-          RCUTILS_LOG_WARN_NAMED("pluginlib.ClassLoader",
+          const char * resource_name_c_str = resource_name.c_str();
+          const char * package_prefix_pair_first_c_str = package_prefix_pair.first.c_str();
+          RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_WARN, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+            "pluginlib.ClassLoader",
             "unexpectedly not able to find ament resource '%s' for package '%s'",
-            resource_name.c_str(),
-            package_prefix_pair.first.c_str()
+            resource_name_c_str,
+            package_prefix_pair_first_c_str
           );
           continue;
         }
@@ -262,7 +297,7 @@ std::vector<std::string> ClassLoader<T>::getPluginXmlPaths(
 }
 
 template<class T>
-std::map<std::string, ClassDesc> ClassLoader<T>::determineAvailableClasses(
+std::map<std::string, ClassDesc> NOINLINE ClassLoader<T>::determineAvailableClasses(
   const std::vector<std::string> & plugin_xml_paths)
 /***************************************************************************/
 {
@@ -271,7 +306,8 @@ std::map<std::string, ClassDesc> ClassLoader<T>::determineAvailableClasses(
   // seem to be correct.
   // With time I keep correcting small things, but a good rewrite is needed.
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Entering determineAvailableClasses()...");
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader", "Entering determineAvailableClasses()...");
   std::map<std::string, ClassDesc> classes_available;
 
   // Walk the list of all plugin XML files (variable "paths") that are exported by the build system
@@ -281,27 +317,32 @@ std::map<std::string, ClassDesc> ClassLoader<T>::determineAvailableClasses(
     try {
       processSingleXMLPluginFile(*it, classes_available);
     } catch (const pluginlib::InvalidXMLException & e) {
-      RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
+      const char * e_what = e.what();
+      RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+        "pluginlib.ClassLoader",
         "Skipped loading plugin with error: %s.",
-        e.what());
+        e_what);
     }
   }
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Exiting determineAvailableClasses()...");
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader", "Exiting determineAvailableClasses()...");
   return classes_available;
 }
 
 template<class T>
-std::string ClassLoader<T>::extractPackageNameFromPackageXML(const std::string & package_xml_path)
+std::string NOINLINE ClassLoader<T>::extractPackageNameFromPackageXML(const std::string & package_xml_path)
 /***************************************************************************/
 {
   tinyxml2::XMLDocument document;
-  document.LoadFile(package_xml_path.c_str());
+  const char * package_xml_path_c_str = package_xml_path.c_str();
+  document.LoadFile(package_xml_path_c_str);
   tinyxml2::XMLElement * doc_root_node = document.FirstChildElement("package");
   if (NULL == doc_root_node) {
-    RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Could not find a root element for package manifest at %s.",
-      package_xml_path.c_str());
+      package_xml_path_c_str);
     return "";
   }
 
@@ -309,19 +350,21 @@ std::string ClassLoader<T>::extractPackageNameFromPackageXML(const std::string &
 
   tinyxml2::XMLElement * package_name_node = doc_root_node->FirstChildElement("name");
   if (NULL == package_name_node) {
-    RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "package.xml at %s does not have a <name> tag! Cannot determine package "
       "which exports plugin.",
-      package_xml_path.c_str());
+      package_xml_path_c_str);
     return "";
   }
 
   const char* package_name_node_txt = package_name_node->GetText();
   if (NULL == package_name_node_txt) {
-    RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
-      "package.xml at %s has an invalid <name> tag! Cannot determine package "
-      "which exports plugin.",
-      package_xml_path.c_str());
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
+       "package.xml at %s has an invalid <name> tag! Cannot determine package "
+       "which exports plugin.",
+       package_xml_path_c_str);
     return "";
   }
 
@@ -329,7 +372,7 @@ std::string ClassLoader<T>::extractPackageNameFromPackageXML(const std::string &
 }
 
 template<class T>
-std::vector<std::string> ClassLoader<T>::getAllLibraryPathsToTry(
+std::vector<std::string> NOINLINE ClassLoader<T>::getAllLibraryPathsToTry(
   const std::string & library_name,
   const std::string & exporting_package_name)
 /***************************************************************************/
@@ -382,12 +425,15 @@ std::vector<std::string> ClassLoader<T>::getAllLibraryPathsToTry(
 
   std::string library_name_alternative;  // either lib<library> or <library> without lib prefix
   const char * lib_prefix = "lib";
+  const char * library_name_c_str = library_name.c_str();
   if (library_name.rfind(lib_prefix, 0) == 0) {
     library_name_alternative = library_name.substr(strlen(lib_prefix));
-    RCUTILS_LOG_WARN_NAMED("pluginlib.ClassLoader",
+    const char * library_name_alternative_c_str = library_name_alternative.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_WARN, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "given plugin name '%s' should be '%s' for better portability",
-      library_name.c_str(),
-      library_name_alternative.c_str());
+      library_name_c_str,
+      library_name_alternative_c_str);
   } else {
     library_name_alternative = lib_prefix + library_name;
   }
@@ -421,31 +467,33 @@ std::vector<std::string> ClassLoader<T>::getAllLibraryPathsToTry(
   }
 
   for (auto && path : all_paths) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    const char * path_c_str = path.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "[search path for '%s']: '%s'",
-      library_name.c_str(),
-      path.c_str());
+      library_name_c_str,
+      path_c_str);
   }
 
   return all_paths;
 }
 
 template<class T>
-bool ClassLoader<T>::isClassLoaded(const std::string & lookup_name)
+bool NOINLINE ClassLoader<T>::isClassLoaded(const std::string & lookup_name)
 /***************************************************************************/
 {
   return lowlevel_class_loader_.isClassAvailable<T>(getClassType(lookup_name));
 }
 
 template<class T>
-std::string ClassLoader<T>::getBaseClassType() const
+std::string NOINLINE ClassLoader<T>::getBaseClassType() const
 /***************************************************************************/
 {
   return base_class_;
 }
 
 template<class T>
-std::string ClassLoader<T>::getClassDescription(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getClassDescription(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
@@ -456,7 +504,7 @@ std::string ClassLoader<T>::getClassDescription(const std::string & lookup_name)
 }
 
 template<class T>
-std::string ClassLoader<T>::getClassType(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getClassType(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
@@ -467,43 +515,52 @@ std::string ClassLoader<T>::getClassType(const std::string & lookup_name)
 }
 
 template<class T>
-std::string ClassLoader<T>::getClassLibraryPath(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getClassLibraryPath(const std::string & lookup_name)
 /***************************************************************************/
 {
   if (classes_available_.find(lookup_name) == classes_available_.end()) {
     std::ostringstream error_msg;
     error_msg << "Could not find library corresponding to plugin " << lookup_name <<
       ". Make sure the plugin description XML file has the correct name of the library.";
-    throw pluginlib::LibraryLoadException(error_msg.str());
+    const std::string error_msg_str = error_msg.str();
+    throw pluginlib::LibraryLoadException(error_msg_str);
   }
   ClassMapIterator it = classes_available_.find(lookup_name);
   std::string library_name = it->second.library_name_;
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  const char * library_name_c_str = library_name.c_str();
+  const char * lookup_name_c_str = lookup_name.c_str();
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "Class %s maps to library %s in classes_available_.",
-    lookup_name.c_str(), library_name.c_str());
+    lookup_name_c_str, library_name_c_str);
 
   std::vector<std::string> paths_to_try =
     getAllLibraryPathsToTry(library_name, it->second.package_);
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader",
     "Iterating through all possible paths where %s could be located...",
-    library_name.c_str());
+    lookup_name_c_str);
   for (auto it = paths_to_try.begin(); it != paths_to_try.end(); it++) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Checking path %s ", it->c_str());
+    const char * it_c_str = it->c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader", "Checking path %s ", it_c_str);
     if (rcpputils::fs::exists(*it)) {
-      RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Library %s found at explicit path %s.",
-        library_name.c_str(), it->c_str());
+      RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+        "pluginlib.ClassLoader", "Library %s found at explicit path %s.",
+         library_name_c_str, it_c_str);
       return *it;
     }
   }
   std::ostringstream error_msg;
   error_msg << "Could not find library corresponding to plugin " << lookup_name <<
     ". Make sure that the library '" << library_name << "' actually exists.";
-  throw pluginlib::LibraryLoadException(error_msg.str());
+  const std::string error_msg_str = error_msg.str();
+  throw pluginlib::LibraryLoadException(error_msg_str);
 }
 
 template<class T>
-std::string ClassLoader<T>::getClassPackage(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getClassPackage(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
@@ -514,14 +571,14 @@ std::string ClassLoader<T>::getClassPackage(const std::string & lookup_name)
 }
 
 template<class T>
-std::vector<std::string> ClassLoader<T>::getPluginXmlPaths()
+std::vector<std::string> NOINLINE ClassLoader<T>::getPluginXmlPaths()
 /***************************************************************************/
 {
   return plugin_xml_paths_;
 }
 
 template<class T>
-std::vector<std::string> ClassLoader<T>::getDeclaredClasses()
+std::vector<std::string> NOINLINE ClassLoader<T>::getDeclaredClasses()
 /***************************************************************************/
 {
   std::vector<std::string> lookup_names;
@@ -533,7 +590,7 @@ std::vector<std::string> ClassLoader<T>::getDeclaredClasses()
 }
 
 template<class T>
-std::string ClassLoader<T>::getErrorStringForUnknownClass(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getErrorStringForUnknownClass(const std::string & lookup_name)
 /***************************************************************************/
 {
   std::string declared_types;
@@ -547,7 +604,7 @@ std::string ClassLoader<T>::getErrorStringForUnknownClass(const std::string & lo
 }
 
 template<class T>
-std::string ClassLoader<T>::getName(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getName(const std::string & lookup_name)
 /***************************************************************************/
 {
   // remove the package name to get the raw plugin name
@@ -557,7 +614,7 @@ std::string ClassLoader<T>::getName(const std::string & lookup_name)
 
 template<class T>
 std::string
-ClassLoader<T>::getPackageFromPluginXMLFilePath(const std::string & plugin_xml_file_path)
+NOINLINE ClassLoader<T>::getPackageFromPluginXMLFilePath(const std::string & plugin_xml_file_path)
 /***************************************************************************/
 {
   // Note: This method takes an input a path to a plugin xml file and must determine which
@@ -595,7 +652,7 @@ ClassLoader<T>::getPackageFromPluginXMLFilePath(const std::string & plugin_xml_f
 }
 
 template<class T>
-std::string ClassLoader<T>::getPathSeparator()
+std::string NOINLINE ClassLoader<T>::getPathSeparator()
 /***************************************************************************/
 {
   return std::string(1, rcpputils::fs::kPreferredSeparator);
@@ -603,7 +660,7 @@ std::string ClassLoader<T>::getPathSeparator()
 
 
 template<class T>
-std::string ClassLoader<T>::getPluginManifestPath(const std::string & lookup_name)
+std::string NOINLINE ClassLoader<T>::getPluginManifestPath(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
@@ -615,21 +672,21 @@ std::string ClassLoader<T>::getPluginManifestPath(const std::string & lookup_nam
 
 
 template<class T>
-std::vector<std::string> ClassLoader<T>::getRegisteredLibraries()
+std::vector<std::string> NOINLINE ClassLoader<T>::getRegisteredLibraries()
 /***************************************************************************/
 {
   return lowlevel_class_loader_.getRegisteredLibraries();
 }
 
 template<class T>
-bool ClassLoader<T>::isClassAvailable(const std::string & lookup_name)
+bool NOINLINE ClassLoader<T>::isClassAvailable(const std::string & lookup_name)
 /***************************************************************************/
 {
   return classes_available_.find(lookup_name) != classes_available_.end();
 }
 
 template<class T>
-std::string ClassLoader<T>::joinPaths(const std::string & path1, const std::string & path2)
+std::string NOINLINE ClassLoader<T>::joinPaths(const std::string & path1, const std::string & path2)
 /***************************************************************************/
 {
   rcpputils::fs::path p1(path1);
@@ -637,14 +694,16 @@ std::string ClassLoader<T>::joinPaths(const std::string & path1, const std::stri
 }
 
 template<class T>
-void ClassLoader<T>::loadLibraryForClass(const std::string & lookup_name)
+void NOINLINE ClassLoader<T>::loadLibraryForClass(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
   if (it == classes_available_.end()) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    const char * lookup_name_c_str = lookup_name.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Class %s has no mapping in classes_available_.",
-      lookup_name.c_str());
+      lookup_name_c_str);
     throw pluginlib::LibraryLoadException(getErrorStringForUnknownClass(lookup_name));
   }
 
@@ -664,14 +723,16 @@ void ClassLoader<T>::loadLibraryForClass(const std::string & lookup_name)
 }
 
 template<class T>
-void ClassLoader<T>::processSingleXMLPluginFile(
+void NOINLINE ClassLoader<T>::processSingleXMLPluginFile(
   const std::string & xml_file, std::map<std::string,
   ClassDesc> & classes_available)
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Processing xml file %s...", xml_file.c_str());
+  const char* xml_file_c_str = xml_file.c_str();
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader", "Processing xml file %s...", xml_file_c_str);
   tinyxml2::XMLDocument document;
-  document.LoadFile(xml_file.c_str());
+  document.LoadFile(xml_file_c_str);
   tinyxml2::XMLElement * config = document.RootElement();
   if (NULL == config) {
     throw pluginlib::InvalidXMLException(
@@ -703,24 +764,27 @@ void ClassLoader<T>::processSingleXMLPluginFile(
   while (library != NULL) {
     const char* path = library->Attribute("path");
     if (NULL == path) {
-      RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
-        "Attribute 'path' in 'library' tag is missing in %s.", xml_file.c_str());
+      RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+       "pluginlib.ClassLoader",
+       "Attribute 'path' in 'library' tag is missing in %s.", xml_file_c_str);
       continue;
     }
     std::string library_path(path);
     if (0 == library_path.size()) {
-      RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
-        "Failed to find Path Attirbute in library element in %s", xml_file.c_str());
+      RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+        "pluginlib.ClassLoader",
+        "Failed to find Path Attirbute in library element in %s", xml_file_c_str);
       continue;
     }
 
     std::string package_name = getPackageFromPluginXMLFilePath(xml_file);
     if ("" == package_name) {
-      RCUTILS_LOG_ERROR_NAMED("pluginlib.ClassLoader",
-        "Could not find package manifest (neither package.xml or deprecated "
-        "manifest.xml) at same directory level as the plugin XML file %s. "
-        "Plugins will likely not be exported properly.\n)",
-        xml_file.c_str());
+      RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_ERROR, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
+         "Could not find package manifest (neither package.xml or deprecated "
+         "manifest.xml) at same directory level as the plugin XML file %s. "
+         "Plugins will likely not be exported properly.\n)",
+         xml_file_c_str);
     }
 
     tinyxml2::XMLElement * class_element = library->FirstChildElement("class");
@@ -744,14 +808,18 @@ void ClassLoader<T>::processSingleXMLPluginFile(
       std::string lookup_name;
       if (class_element->Attribute("name") != NULL) {
         lookup_name = class_element->Attribute("name");
-        RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-          "XML file specifies lookup name (i.e. magic name) = %s.",
-          lookup_name.c_str());
+        const char* lookup_name_c_str = lookup_name.c_str();
+        RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+          "pluginlib.ClassLoader",
+           "XML file specifies lookup name (i.e. magic name) = %s.",
+           lookup_name_c_str);
       } else {
-        RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-          "XML file has no lookup name (i.e. magic name) for class %s, "
-          "assuming lookup_name == real class name.",
-          derived_class.c_str());
+        const char* derived_class_c_str = derived_class.c_str();
+        RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+          "pluginlib.ClassLoader",
+           "XML file has no lookup name (i.e. magic name) for class %s, "
+           "assuming lookup_name == real class name.",
+           derived_class_c_str);
         lookup_name = derived_class;
       }
 
@@ -779,10 +847,11 @@ void ClassLoader<T>::processSingleXMLPluginFile(
 }
 
 template<class T>
-void ClassLoader<T>::refreshDeclaredClasses()
+void NOINLINE ClassLoader<T>::refreshDeclaredClasses()
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Refreshing declared classes.");
+  RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+    "pluginlib.ClassLoader", "Refreshing declared classes.");
   // determine classes not currently loaded for removal
   std::list<std::string> remove_classes;
   for (std::map<std::string, ClassDesc>::const_iterator it = classes_available_.begin();
@@ -813,7 +882,7 @@ void ClassLoader<T>::refreshDeclaredClasses()
 }
 
 template<class T>
-std::string ClassLoader<T>::stripAllButFileFromPath(const std::string & path)
+std::string NOINLINE ClassLoader<T>::stripAllButFileFromPath(const std::string & path)
 /***************************************************************************/
 {
   std::string only_file;
@@ -826,15 +895,18 @@ std::string ClassLoader<T>::stripAllButFileFromPath(const std::string & path)
 }
 
 template<class T>
-int ClassLoader<T>::unloadLibraryForClass(const std::string & lookup_name)
+int NOINLINE ClassLoader<T>::unloadLibraryForClass(const std::string & lookup_name)
 /***************************************************************************/
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
   if (it != classes_available_.end() && it->second.resolved_library_path_ != "UNRESOLVED") {
     std::string library_path = it->second.resolved_library_path_;
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    const char * library_path_c_str = library_path.c_str();
+    const char * lookup_name_c_str = lookup_name.c_str();
+    RCUTILS_LOG_COND_NAMED(RCUTILS_LOG_SEVERITY_DEBUG, RCUTILS_LOG_CONDITION_EMPTY, RCUTILS_LOG_CONDITION_EMPTY,
+      "pluginlib.ClassLoader",
       "Attempting to unload library %s for class %s",
-      library_path.c_str(), lookup_name.c_str());
+      library_path_c_str, lookup_name_c_str);
     return unloadClassLibraryInternal(library_path);
   } else {
     throw pluginlib::LibraryUnloadException(getErrorStringForUnknownClass(lookup_name));
@@ -842,7 +914,7 @@ int ClassLoader<T>::unloadLibraryForClass(const std::string & lookup_name)
 }
 
 template<class T>
-int ClassLoader<T>::unloadClassLibraryInternal(const std::string & library_path)
+int NOINLINE ClassLoader<T>::unloadClassLibraryInternal(const std::string & library_path)
 /***************************************************************************/
 {
   return lowlevel_class_loader_.unloadLibrary(library_path);
