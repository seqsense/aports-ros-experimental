diff --git a/.travis.yml b/.travis.yml
index 5c8309d..72b2418 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,27 +1,43 @@
-sudo: required
-dist: trusty
-language: generic
-compiler:
-  - gcc
-
-branches:
-  only:
-    - master
-    - develop
+# this is .traivs.yml written by -
 
+# https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/devel_jobs.rst
+# https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/prerelease_jobs.rst
+# while this doesn't require sudo we don't want to run within a Docker container
+sudo: true
+dist: trusty
+language: python
+python:
+  - "3.6"
+env:
+  global:
+    - JOB_PATH=/tmp/devel_job
+    - ABORT_ON_TEST_FAILURE=1
+  matrix:
+    - ROS_DISTRO_NAME=kinetic OS_NAME=ubuntu OS_CODE_NAME=xenial ARCH=amd64
+    - ROS_DISTRO_NAME=melodic OS_NAME=ubuntu OS_CODE_NAME=bionic ARCH=amd64
+    - ROS_DISTRO_NAME=noetic  OS_NAME=ubuntu OS_CODE_NAME=focal  ARCH=amd64
+#   matrix:
+#     allow_failures:
+#       - env: ROS_DISTRO_NAME=kinetic OS_NAME=ubuntu OS_CODE_NAME=xenial ARCH=amd64
 install:
-  - sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu trusty main" > /etc/apt/sources.list.d/ros-latest.list'
-  - wget http://packages.ros.org/ros.key -O - | sudo apt-key add -
-  - sudo apt-get update -qq
-  - sudo apt-get install python-catkin-pkg python-rosdep ros-indigo-catkin -qq
-  - sudo rosdep init
-  - rosdep update 
-  - mkdir -p /tmp/ws/src
-  - ln -s `pwd` /tmp/ws/src/package
-  - cd /tmp/ws
-  - rosdep install --from-paths src --ignore-src --rosdistro indigo -y
-
+  # either install the latest released version of ros_buildfarm
+  - pip install ros_buildfarm
+  # or checkout a specific branch
+  #- git clone -b master https://github.com/ros-infrastructure/ros_buildfarm /tmp/ros_buildfarm
+  #- pip install /tmp/ros_buildfarm
+  # checkout catkin for catkin_test_results script
+  - git clone https://github.com/ros/catkin /tmp/catkin
+  # run devel job for a ROS repository with the same name as this repo
+  - export REPOSITORY_NAME=`basename $TRAVIS_BUILD_DIR`
+  # use the code already checked out by Travis
+  - mkdir -p $JOB_PATH/ws/src
+  - cp -R $TRAVIS_BUILD_DIR $JOB_PATH/ws/src/
+  # generate the script to run a pre-release job for that target and repo
+  - generate_prerelease_script.py https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml $ROS_DISTRO_NAME default $OS_NAME $OS_CODE_NAME $ARCH  --output-dir $JOB_PATH
+  # run the actual job which involves Docker
+  - cd $JOB_PATH; sh ./prerelease.sh -y
 script:
-  - source /opt/ros/indigo/setup.bash
-  - catkin_make
-  - catkin_make install
+  # get summary of test results
+  - /tmp/catkin/bin/catkin_test_results $JOB_PATH/ws/test_results --all
+notifications:
+  email: false
diff --git a/CMakeLists.txt b/CMakeLists.txt
index be662c4..a4def22 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -36,8 +36,8 @@ include_directories(include
 ## Build the USB camera library
 add_library(${PROJECT_NAME} src/usb_cam.cpp)
 target_link_libraries(${PROJECT_NAME}
-  ${avcodec_LIBRARIES}
-  ${swscale_LIBRARIES}
+  ${avcodec_LINK_LIBRARIES}
+  ${swscale_LINK_LIBRARIES}
   ${catkin_LIBRARIES}
 )
 
@@ -45,8 +45,8 @@ target_link_libraries(${PROJECT_NAME}
 add_executable(${PROJECT_NAME}_node nodes/usb_cam_node.cpp)
 target_link_libraries(${PROJECT_NAME}_node
   ${PROJECT_NAME}
-  ${avcodec_LIBRARIES}
-  ${swscale_LIBRARIES}
+  ${avcodec_LINK_LIBRARIES}
+  ${swscale_LINK_LIBRARIES}
   ${catkin_LIBRARIES}
 )
 
diff --git a/include/usb_cam/usb_cam.h b/include/usb_cam/usb_cam.h
index 05347fb..70d0344 100644
--- a/include/usb_cam/usb_cam.h
+++ b/include/usb_cam/usb_cam.h
@@ -44,6 +44,7 @@ extern "C"
 #include <libavcodec/avcodec.h>
 #include <libswscale/swscale.h>
 #include <libavutil/mem.h>
+#include <libavutil/imgutils.h>
 }
 
 // legacy reasons
diff --git a/src/usb_cam.cpp b/src/usb_cam.cpp
index f9eeea0..aaed2d0 100644
--- a/src/usb_cam.cpp
+++ b/src/usb_cam.cpp
@@ -365,9 +365,11 @@ UsbCam::~UsbCam()
 
 int UsbCam::init_mjpeg_decoder(int image_width, int image_height)
 {
-  avcodec_register_all();
+  #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
+     avcodec_register_all();
+  #endif
 
-  avcodec_ = avcodec_find_decoder(AV_CODEC_ID_MJPEG);
+  avcodec_ = const_cast<AVCodec*>(avcodec_find_decoder(AV_CODEC_ID_MJPEG));
   if (!avcodec_)
   {
     ROS_ERROR("Could not find MJPEG decoder");
@@ -383,7 +385,12 @@ int UsbCam::init_mjpeg_decoder(int image_width, int image_height)
   avframe_rgb_ = av_frame_alloc();
 #endif
 
-  avpicture_alloc((AVPicture *)avframe_rgb_, AV_PIX_FMT_RGB24, image_width, image_height);
+  avframe_rgb_ = av_frame_alloc();
+  avframe_rgb_->format = AV_PIX_FMT_RGB24;
+  avframe_rgb_->width = image_width;
+  avframe_rgb_->height = image_height;
+  av_frame_get_buffer(avframe_rgb_, 32);
+  //avpicture_alloc(avframe_rgb_, AV_PIX_FMT_RGB24, image_width, image_height);
 
   avcodec_context_->codec_id = AV_CODEC_ID_MJPEG;
   avcodec_context_->width = image_width;
@@ -394,8 +401,8 @@ int UsbCam::init_mjpeg_decoder(int image_width, int image_height)
   avcodec_context_->codec_type = AVMEDIA_TYPE_VIDEO;
 #endif
 
-  avframe_camera_size_ = avpicture_get_size(AV_PIX_FMT_YUV422P, image_width, image_height);
-  avframe_rgb_size_ = avpicture_get_size(AV_PIX_FMT_RGB24, image_width, image_height);
+  avframe_camera_size_ = av_image_get_buffer_size(AV_PIX_FMT_YUV422P, image_width, image_height, 32);
+  avframe_rgb_size_ = av_image_get_buffer_size(AV_PIX_FMT_RGB24, image_width, image_height, 32);
 
   /* open it */
   if (avcodec_open2(avcodec_context_, avcodec_, &avoptions_) < 0)
@@ -417,10 +424,11 @@ void UsbCam::mjpeg2rgb(char *MJPEG, int len, char *RGB, int NumPixels)
   AVPacket avpkt;
   av_init_packet(&avpkt);
 
-  avpkt.size = len;
-  avpkt.data = (unsigned char*)MJPEG;
-  decoded_len = avcodec_decode_video2(avcodec_context_, avframe_camera_, &got_picture, &avpkt);
-
+  //avpkt.size = len;
+  //avpkt.data = (unsigned char*)MJPEG;
+  av_packet_from_data (&avpkt, (unsigned char*)MJPEG, len);
+  decoded_len = avcodec_send_packet(avcodec_context_, &avpkt);
+  //decoded_len = avcodec_decode_video2(avcodec_context_, avframe_camera_, &got_picture, &avpkt);
   if (decoded_len < 0)
   {
     ROS_ERROR("Error while decoding frame.");
@@ -428,30 +436,37 @@ void UsbCam::mjpeg2rgb(char *MJPEG, int len, char *RGB, int NumPixels)
   }
 #else
   avcodec_decode_video(avcodec_context_, avframe_camera_, &got_picture, (uint8_t *) MJPEG, len);
-#endif
-
   if (!got_picture)
   {
     ROS_ERROR("Webcam: expected picture but didn't get it...");
     return;
   }
+#endif
+  
+  if (avcodec_receive_frame(avcodec_context_, avframe_camera_) < 0)
+  {
+    ROS_ERROR("Error while returning frame.");
+    return;
+  }
 
   int xsize = avcodec_context_->width;
   int ysize = avcodec_context_->height;
-  int pic_size = avpicture_get_size(avcodec_context_->pix_fmt, xsize, ysize);
+  int pic_size = av_image_get_buffer_size(avcodec_context_->pix_fmt, xsize, ysize, 32);
   if (pic_size != avframe_camera_size_)
   {
     ROS_ERROR("outbuf size mismatch.  pic_size: %d bufsize: %d", pic_size, avframe_camera_size_);
     return;
   }
+  //avframe_rgb_size_ = av_image_get_buffer_size(AV_PIX_FMT_RGB24, avcodec_context_->width, avcodec_context_->height, 32);
+  //unsigned char* frame_buffer = (uint8_t*)av_malloc(avframe_rgb_size_);
+  //av_image_fill_arrays(avframe_rgb_->data, avframe_rgb_->linesize, frame_buffer, AV_PIX_FMT_RGB24, avframe_rgb_->width, avframe_rgb_->height, 32);         
 
-  video_sws_ = sws_getContext(xsize, ysize, avcodec_context_->pix_fmt, xsize, ysize, AV_PIX_FMT_RGB24, SWS_BILINEAR, NULL,
-			      NULL,  NULL);
-  sws_scale(video_sws_, avframe_camera_->data, avframe_camera_->linesize, 0, ysize, avframe_rgb_->data,
-            avframe_rgb_->linesize);
+  video_sws_ = sws_getContext(xsize, ysize, avcodec_context_->pix_fmt, xsize, ysize, AV_PIX_FMT_RGB24, SWS_FAST_BILINEAR, NULL, NULL,  NULL);
+  sws_scale(video_sws_, avframe_camera_->data, avframe_camera_->linesize, 0, ysize, avframe_rgb_->data, avframe_rgb_->linesize);
   sws_freeContext(video_sws_);
-
-  int size = avpicture_layout((AVPicture *)avframe_rgb_, AV_PIX_FMT_RGB24, xsize, ysize, (uint8_t *)RGB, avframe_rgb_size_);
+  
+  //int size = avpicture_layout((AVPicture *)avframe_rgb_, AV_PIX_FMT_RGB24, xsize, ysize, (uint8_t *)RGB, avframe_rgb_size_);
+  int size = av_image_copy_to_buffer((uint8_t *)RGB, avframe_rgb_size_, avframe_rgb_->data, avframe_rgb_->linesize, AV_PIX_FMT_RGB24, xsize, ysize, 32);
   if (size != avframe_rgb_size_)
   {
     ROS_ERROR("webcam: avpicture_layout error: %d", size);
