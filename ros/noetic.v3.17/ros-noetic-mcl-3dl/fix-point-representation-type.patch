diff --git a/include/mcl_3dl/chunked_kdtree.h b/include/mcl_3dl/chunked_kdtree.h
index 5238724..e9d6c56 100644
--- a/include/mcl_3dl/chunked_kdtree.h
+++ b/include/mcl_3dl/chunked_kdtree.h
@@ -109,7 +109,7 @@ public:
     }
   }
   void setPointRepresentation(
-      boost::shared_ptr<pcl::PointRepresentation<POINT_TYPE>> point_rep)
+      const typename pcl::PointRepresentation<POINT_TYPE>::ConstPtr point_rep)
   {
     point_rep_ = point_rep;
     for (auto& chunk : chunks_)
@@ -204,7 +204,9 @@ public:
     for (auto& cloud : clouds)
     {
       if (point_rep_)
+      {
         chunks_[cloud.first].kdtree_->setPointRepresentation(point_rep_);
+      }
       if (set_epsilon_)
         chunks_[cloud.first].kdtree_->setEpsilon(epsilon_);
       auto cloud_ptr = cloud.second.makeShared();
@@ -283,7 +285,7 @@ protected:
   bool set_epsilon_;
   bool keep_clouds_;
   float epsilon_;
-  boost::shared_ptr<pcl::PointRepresentation<POINT_TYPE>> point_rep_;
+  typename pcl::PointRepresentation<POINT_TYPE>::ConstPtr point_rep_;
 
   using ChunkMap = std::unordered_map<ChunkId, Chunk, ChunkId>;
   using ChunkCloud = std::unordered_map<ChunkId, typename pcl::PointCloud<POINT_TYPE>, ChunkId>;
diff --git a/src/mcl_3dl.cpp b/src/mcl_3dl.cpp
index 71219e6..f2cf049 100644
--- a/src/mcl_3dl.cpp
+++ b/src/mcl_3dl.cpp
@@ -111,11 +111,21 @@ protected:
   class MyPointRepresentation : public pcl::PointRepresentation<PointType>
   {
     using pcl::PointRepresentation<PointType>::nr_dimensions_;
+    using pcl::PointRepresentation<PointType>::alpha_;
 
   public:
     MyPointRepresentation()
     {
+      ROS_ERROR("construct MyPointRepresentation");
       nr_dimensions_ = 3;
+      trivial_ = true;
+    }
+
+    void debug() const
+    {
+      ROS_ERROR("%d %0.3f %0.3f %0.3f",
+          nr_dimensions_,
+          alpha_[0], alpha_[1], alpha_[2]);
     }
 
     virtual void copyToFloatArray(const PointType& p, float* out) const
@@ -1056,10 +1066,7 @@ protected:
     ds.filter(*points);
 
     pcl::KdTreeFLANN<PointType>::Ptr kdtree(new pcl::KdTreeFLANN<PointType>);
-    kdtree->setPointRepresentation(
-        boost::dynamic_pointer_cast<
-            pcl::PointRepresentation<PointType>,
-            MyPointRepresentation>(boost::make_shared<MyPointRepresentation>(point_rep_)));
+    kdtree->setPointRepresentation(point_rep_);
     kdtree->setInputCloud(points);
 
     auto pc_filter = [this, kdtree](const PointType& p)
@@ -1217,6 +1224,7 @@ public:
     , tfl_(tfbuf_)
     , cnt_measure_(0)
     , global_localization_fix_cnt_(0)
+    , point_rep_(new MyPointRepresentation)
     , engine_(seed_gen_())
   {
   }
@@ -1284,7 +1292,7 @@ public:
         pnh_, "expansion_resetting", &MCL3dlNode::cbExpansionReset, this);
     srv_load_pcd_ = nh_.advertiseService("load_pcd", &MCL3dlNode::cbLoadPCD, this);
 
-    point_rep_.setRescaleValues(params_.dist_weight_.data());
+    point_rep_->setRescaleValues(params_.dist_weight_.data());
 
     pf_.reset(new pf::ParticleFilter<State6DOF,
                                      float,
@@ -1350,10 +1358,7 @@ public:
     ROS_DEBUG("max_search_radius: %0.3f", max_search_radius);
     kdtree_.reset(new ChunkedKdtree<PointType>(params_.map_chunk_, max_search_radius));
     kdtree_->setEpsilon(params_.map_grid_min_ / 16);
-    kdtree_->setPointRepresentation(
-        boost::dynamic_pointer_cast<
-            pcl::PointRepresentation<PointType>,
-            MyPointRepresentation>(boost::make_shared<MyPointRepresentation>(point_rep_)));
+    kdtree_->setPointRepresentation(point_rep_);
 
     map_update_timer_ = nh_.createTimer(
         *params_.map_update_interval_,
@@ -1456,7 +1461,7 @@ protected:
   diagnostic_updater::Updater diag_updater_;
   mcl_3dl_msgs::Status status_;
 
-  MyPointRepresentation point_rep_;
+  MyPointRepresentation::Ptr point_rep_;
 
   pcl::PointCloud<PointType>::Ptr pc_map_;
   pcl::PointCloud<PointType>::Ptr pc_map2_;
