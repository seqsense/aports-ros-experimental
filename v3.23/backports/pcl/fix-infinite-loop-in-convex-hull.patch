diff --git a/surface/include/pcl/surface/convex_hull.h b/surface/include/pcl/surface/convex_hull.h
index 330a4b80e..4590230bc 100644
--- a/surface/include/pcl/surface/convex_hull.h
+++ b/surface/include/pcl/surface/convex_hull.h
@@ -244,6 +261,9 @@ namespace pcl
       /** \brief The dimensionality of the concave hull (2D or 3D). */
       int dimension_{0};
 
+      /** \brief The number of the initial convex selection retry. */
+      int num_initial_convex_selection_retry_{10000};
+
       /** \brief How close can a 2D plane's normal be to an axis to make projection problematic. */
       double projection_angle_thresh_{std::cos (0.174532925)};
 
diff --git a/surface/include/pcl/surface/impl/convex_hull.hpp b/surface/include/pcl/surface/impl/convex_hull.hpp
index d17f47b9d..0e9bda430 100644
--- a/surface/include/pcl/surface/impl/convex_hull.hpp
+++ b/surface/include/pcl/surface/impl/convex_hull.hpp
@@ -85,9 +85,13 @@ pcl::ConvexHull<PointInT>::performReconstruction2D (PointCloud &hull, std::vecto
   PointInT p0 = (*input_)[(*indices_)[0]];
   PointInT p1 = (*input_)[(*indices_)[indices_->size () - 1]];
   PointInT p2 = (*input_)[(*indices_)[indices_->size () / 2]];
+  int retries = num_initial_convex_selection_retry_;
   while (!pcl::isXYZFinite(p0) || !pcl::isXYZFinite(p1) || !pcl::isXYZFinite(p2) || 
   (p1.getVector3fMap() - p0.getVector3fMap()).cross(p2.getVector3fMap() - p0.getVector3fMap()).stableNorm() < Eigen::NumTraits<float>::dummy_precision ())
   {
+    if (retries-- <= 0) {
+      break;
+    }
     p0 = (*input_)[(*indices_)[rand () % indices_->size ()]];
     p1 = (*input_)[(*indices_)[rand () % indices_->size ()]];
     p2 = (*input_)[(*indices_)[rand () % indices_->size ()]];
diff --git a/test/surface/test_convex_hull.cpp b/test/surface/test_convex_hull.cpp
index f814cb89a..0c9970bb1 100644
--- a/test/surface/test_convex_hull.cpp
+++ b/test/surface/test_convex_hull.cpp
@@ -39,7 +39,11 @@
 
 #include <pcl/test/gtest.h>
 
+#include <atomic>
+#include <chrono>
+#include <cstdlib>
 #include <random>
+#include <thread>
 
 #include <pcl/point_types.h>
 #include <pcl/io/pcd_io.h>
@@ -484,6 +488,77 @@ TEST (PCL, ConvexHull_4points)
   EXPECT_NEAR (convex_hull.getTotalArea (), 1.0f, 1e-6);
 }
 
+TEST (PCL, ConvexHull_insufficient_points)
+{
+  // ConvexHull must not enter an infinite busy loop
+  // even if insufficient points are passed
+
+  // PCL 1.15.0 and 1.15.1 enter infinite busy loop if insufficient points are passed.
+  // Use EXPECT_EXIT to run the convex hull calculation in a sub-process to
+  // safely check the timeout.
+  const auto check_no_timeout = [](pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud) {
+    std::atomic_bool finished = false;
+    std::thread thread([&]() {
+      using namespace std::chrono_literals;
+      std::this_thread::sleep_for(1s);
+      if (!finished) {
+        abort(); // Abort if deadline exceeded
+      }
+    });
+
+    ConvexHull<PointXYZ> convex_hull;
+    convex_hull.setComputeAreaVolume(true);
+    convex_hull.setInputCloud(cloud);
+
+    PolygonMesh mesh;
+    convex_hull.reconstruct(mesh);
+    finished = true;
+    EXPECT_EQ(mesh.polygons.size(), 0);
+    thread.join();
+    exit(0); // Exit if process returned
+  };
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr input_cloud(new pcl::PointCloud<pcl::PointXYZ>());
+  pcl::PointXYZ p;
+  p.x = p.y = p.z = 0.f;
+  input_cloud->push_back(p);
+
+  EXPECT_EXIT(
+      {
+        SCOPED_TRACE("1 point");
+        check_no_timeout(input_cloud);
+      },
+      ::testing::ExitedWithCode(0),
+      ".*")
+      << "Did not return against 1 point input";
+
+  p.x = 0.1f;
+  p.y = p.z = 0.f;
+  input_cloud->push_back(p);
+
+  EXPECT_EXIT(
+      {
+        SCOPED_TRACE("2 points");
+        check_no_timeout(input_cloud);
+      },
+      ::testing::ExitedWithCode(0),
+      ".*")
+      << "Did not return against 2 point input";
+
+  p.x = 0.2f;
+  p.y = p.z = 0.f;
+  input_cloud->push_back(p);
+
+  EXPECT_EXIT(
+      {
+        SCOPED_TRACE("3 points on a line");
+        check_no_timeout(input_cloud);
+      },
+      ::testing::ExitedWithCode(0),
+      ".*")
+      << "Did not return against 3 point input on a line";
+}
+
 /* ---[ */
 int
 main (int argc, char** argv)
