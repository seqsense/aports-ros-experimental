diff --git a/include/pluginlib/class_loader_imp.hpp b/include/pluginlib/class_loader_imp.hpp
index 67a70cf..c6c94bc 100644
--- a/include/pluginlib/class_loader_imp.hpp
+++ b/include/pluginlib/class_loader_imp.hpp
@@ -85,8 +85,8 @@ ClassLoader<T>::ClassLoader(
   lowlevel_class_loader_(false)
   /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Creating ClassLoader, base = %s, address = %p",
-    base_class.c_str(), static_cast<void *>(this));
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Creating ClassLoader, base = %s, address = %p",
+  //   base_class.c_str(), static_cast<void *>(this));
   try {
     ament_index_cpp::get_package_prefix(package_);
   } catch (const ament_index_cpp::PackageNotFoundError & exception) {
@@ -98,18 +98,18 @@ ClassLoader<T>::ClassLoader(
     plugin_xml_paths_ = getPluginXmlPaths(package_, attrib_name_);
   }
   classes_available_ = determineAvailableClasses(plugin_xml_paths_);
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Finished constructring ClassLoader, base = %s, address = %p",
-    base_class.c_str(), static_cast<void *>(this));
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Finished constructring ClassLoader, base = %s, address = %p",
+  //   base_class.c_str(), static_cast<void *>(this));
 }
 
 template<class T>
 ClassLoader<T>::~ClassLoader()
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Destroying ClassLoader, base = %s, address = %p",
-    getBaseClassType().c_str(), static_cast<void *>(this));
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Destroying ClassLoader, base = %s, address = %p",
+  //   getBaseClassType().c_str(), static_cast<void *>(this));
 }
 
 
@@ -118,28 +118,28 @@ T * ClassLoader<T>::createClassInstance(const std::string & lookup_name, bool au
 /***************************************************************************/
 {
   // Note: This method is deprecated
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "In deprecated call createClassInstance(), lookup_name = %s, auto_load = %i.",
-    (lookup_name.c_str()), auto_load);
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "In deprecated call createClassInstance(), lookup_name = %s, auto_load = %i.",
+  //   (lookup_name.c_str()), auto_load);
 
   if (auto_load && !isClassLoaded(lookup_name)) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Autoloading class library before attempting to create instance.");
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Autoloading class library before attempting to create instance.");
     loadLibraryForClass(lookup_name);
   }
 
   try {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Attempting to create instance through low-level MultiLibraryClassLoader...");
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Attempting to create instance through low-level MultiLibraryClassLoader...");
     T * obj = lowlevel_class_loader_.createUnmanagedInstance<T>(getClassType(lookup_name));
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Instance created with object pointer = %p", static_cast<void *>(obj));
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Instance created with object pointer = %p", static_cast<void *>(obj));
 
     return obj;
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "CreateClassException about to be raised for class %s",
-      lookup_name.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "CreateClassException about to be raised for class %s",
+    //   lookup_name.c_str());
     throw pluginlib::CreateClassException(ex.what());
   }
 }
@@ -154,9 +154,9 @@ std::shared_ptr<T> ClassLoader<T>::createSharedInstance(const std::string & look
 template<class T>
 UniquePtr<T> ClassLoader<T>::createUniqueInstance(const std::string & lookup_name)
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Attempting to create managed (unique) instance for class %s.",
-    lookup_name.c_str());
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Attempting to create managed (unique) instance for class %s.",
+  //   lookup_name.c_str());
 
   if (!isClassLoaded(lookup_name)) {
     loadLibraryForClass(lookup_name);
@@ -164,21 +164,21 @@ UniquePtr<T> ClassLoader<T>::createUniqueInstance(const std::string & lookup_nam
 
   try {
     std::string class_type = getClassType(lookup_name);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
-      lookup_name.c_str(), class_type.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
+    //   lookup_name.c_str(), class_type.c_str());
 
     UniquePtr<T> obj = lowlevel_class_loader_.createUniqueInstance<T>(class_type);
 
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "std::unique_ptr to object of real type %s created.",
-      class_type.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "std::unique_ptr to object of real type %s created.",
+    //   class_type.c_str());
 
     return obj;
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Exception raised by low-level multi-library class loader when attempting "
-      "to create instance of class %s.",
-      lookup_name.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Exception raised by low-level multi-library class loader when attempting "
+    //   "to create instance of class %s.",
+    //   lookup_name.c_str());
     throw pluginlib::CreateClassException(ex.what());
   }
 }
@@ -187,9 +187,9 @@ template<class T>
 T * ClassLoader<T>::createUnmanagedInstance(const std::string & lookup_name)
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Attempting to create UNMANAGED instance for class %s.",
-    lookup_name.c_str());
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Attempting to create UNMANAGED instance for class %s.",
+  //   lookup_name.c_str());
 
   if (!isClassLoaded(lookup_name)) {
     loadLibraryForClass(lookup_name);
@@ -197,20 +197,20 @@ T * ClassLoader<T>::createUnmanagedInstance(const std::string & lookup_name)
 
   T * instance = 0;
   try {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Attempting to create instance through low level multi-library class loader.");
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Attempting to create instance through low level multi-library class loader.");
     std::string class_type = getClassType(lookup_name);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
-      lookup_name.c_str(), class_type.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "%s maps to real class type %s",
+    //   lookup_name.c_str(), class_type.c_str());
     instance = lowlevel_class_loader_.createUnmanagedInstance<T>(class_type);
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Instance of type %s created.",
-      class_type.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Instance of type %s created.",
+    //   class_type.c_str());
   } catch (const class_loader::CreateClassException & ex) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Exception raised by low-level multi-library class loader when attempting "
-      "to create UNMANAGED instance of class %s.",
-      lookup_name.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Exception raised by low-level multi-library class loader when attempting "
+    //   "to create UNMANAGED instance of class %s.",
+    //   lookup_name.c_str());
     throw pluginlib::CreateClassException(ex.what());
   }
   return instance;
@@ -271,7 +271,7 @@ std::map<std::string, ClassDesc> ClassLoader<T>::determineAvailableClasses(
   // seem to be correct.
   // With time I keep correcting small things, but a good rewrite is needed.
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Entering determineAvailableClasses()...");
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Entering determineAvailableClasses()...");
   std::map<std::string, ClassDesc> classes_available;
 
   // Walk the list of all plugin XML files (variable "paths") that are exported by the build system
@@ -287,7 +287,7 @@ std::map<std::string, ClassDesc> ClassLoader<T>::determineAvailableClasses(
     }
   }
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Exiting determineAvailableClasses()...");
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Exiting determineAvailableClasses()...");
   return classes_available;
 }
 
@@ -417,10 +417,10 @@ std::vector<std::string> ClassLoader<T>::getAllLibraryPathsToTry(
   }
 
   for (auto && path : all_paths) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "[search path for '%s']: '%s'",
-      library_name.c_str(),
-      path.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "[search path for '%s']: '%s'",
+    //   library_name.c_str(),
+    //   path.c_str());
   }
 
   return all_paths;
@@ -474,21 +474,21 @@ std::string ClassLoader<T>::getClassLibraryPath(const std::string & lookup_name)
   }
   ClassMapIterator it = classes_available_.find(lookup_name);
   std::string library_name = it->second.library_name_;
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Class %s maps to library %s in classes_available_.",
-    lookup_name.c_str(), library_name.c_str());
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Class %s maps to library %s in classes_available_.",
+  //   lookup_name.c_str(), library_name.c_str());
 
   std::vector<std::string> paths_to_try =
     getAllLibraryPathsToTry(library_name, it->second.package_);
 
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-    "Iterating through all possible paths where %s could be located...",
-    library_name.c_str());
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+  //   "Iterating through all possible paths where %s could be located...",
+  //   library_name.c_str());
   for (auto path_it = paths_to_try.begin(); path_it != paths_to_try.end(); path_it++) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Checking path %s ", path_it->c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Checking path %s ", path_it->c_str());
     if (std::filesystem::exists(*path_it)) {
-      RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Library %s found at explicit path %s.",
-        library_name.c_str(), path_it->c_str());
+      // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Library %s found at explicit path %s.",
+      //   library_name.c_str(), path_it->c_str());
       return *path_it;
     }
   }
@@ -638,9 +638,9 @@ void ClassLoader<T>::loadLibraryForClass(const std::string & lookup_name)
 {
   ClassMapIterator it = classes_available_.find(lookup_name);
   if (it == classes_available_.end()) {
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Class %s has no mapping in classes_available_.",
-      lookup_name.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Class %s has no mapping in classes_available_.",
+    //   lookup_name.c_str());
     throw pluginlib::LibraryLoadException(getErrorStringForUnknownClass(lookup_name));
   }
 
@@ -665,7 +665,7 @@ void ClassLoader<T>::processSingleXMLPluginFile(
   ClassDesc> & classes_available)
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Processing xml file %s...", xml_file.c_str());
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Processing xml file %s...", xml_file.c_str());
   tinyxml2::XMLDocument document;
   document.LoadFile(xml_file.c_str());
   tinyxml2::XMLElement * config = document.RootElement();
@@ -740,14 +740,14 @@ void ClassLoader<T>::processSingleXMLPluginFile(
       std::string lookup_name;
       if (class_element->Attribute("name") != NULL) {
         lookup_name = class_element->Attribute("name");
-        RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-          "XML file specifies lookup name (i.e. magic name) = %s.",
-          lookup_name.c_str());
+        // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+        //   "XML file specifies lookup name (i.e. magic name) = %s.",
+        //   lookup_name.c_str());
       } else {
-        RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-          "XML file has no lookup name (i.e. magic name) for class %s, "
-          "assuming lookup_name == real class name.",
-          derived_class.c_str());
+        // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+        //   "XML file has no lookup name (i.e. magic name) for class %s, "
+        //   "assuming lookup_name == real class name.",
+        //   derived_class.c_str());
         lookup_name = derived_class;
       }
 
@@ -778,7 +778,7 @@ template<class T>
 void ClassLoader<T>::refreshDeclaredClasses()
 /***************************************************************************/
 {
-  RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Refreshing declared classes.");
+  // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader", "Refreshing declared classes.");
   // determine classes not currently loaded for removal
   std::list<std::string> remove_classes;
   for (std::map<std::string, ClassDesc>::const_iterator it = classes_available_.begin();
@@ -828,9 +828,9 @@ int ClassLoader<T>::unloadLibraryForClass(const std::string & lookup_name)
   ClassMapIterator it = classes_available_.find(lookup_name);
   if (it != classes_available_.end() && it->second.resolved_library_path_ != "UNRESOLVED") {
     std::string library_path = it->second.resolved_library_path_;
-    RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
-      "Attempting to unload library %s for class %s",
-      library_path.c_str(), lookup_name.c_str());
+    // RCUTILS_LOG_DEBUG_NAMED("pluginlib.ClassLoader",
+    //   "Attempting to unload library %s for class %s",
+    //   library_path.c_str(), lookup_name.c_str());
     return unloadClassLibraryInternal(library_path);
   } else {
     throw pluginlib::LibraryUnloadException(getErrorStringForUnknownClass(lookup_name));
